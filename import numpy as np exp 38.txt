import numpy as np

def mod_inverse(a, m=26):
    a = a % m
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    return None

def matrix_mod_inv(matrix, m=26):
    det = int(np.round(np.linalg.det(matrix)))
    det = det % m
    inv_det = mod_inverse(det, m)
    if inv_det is None:
        raise ValueError("Matrix not invertible mod 26")

    adj = np.array([[matrix[1,1], -matrix[0,1]],
                    [-matrix[1,0], matrix[0,0]]])
    
    return (inv_det * adj) % m

# Example plaintext and ciphertext matrices
P = np.array([[7, 8],
              [11, 11]])

C = np.array([[17, 20],
              [5, 12]])

# Compute K = P^-1 * C mod 26
P_inv = matrix_mod_inv(P)
K = (P_inv.dot(C)) % 26

print("Recovered Key Matrix:")
print(K)

output
Recovered Key Matrix:
[[3 10]
 [20 9]]
